/**
 * Copyright 2020 The Nakama Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { CloseEvent, ErrorEvent } from "ws";
import { ApiRegisterStreamingChannelRequest, ApiVoiceChannelUserList, MessagePayLoad, MessageUserPayLoad, Socket, TokenSentEvent } from "./interfaces";
import { Session } from "./session";
import { WebSocketAdapter } from "./web_socket_adapter";
import { Events } from "./constants/enum";
import { Client, ApiChannelDescription, ApiCreateChannelDescRequest, ChannelMessageContent, ApiMessageMention, ApiMessageAttachment, ApiMessageRef } from "./interfaces";
import { Stack } from "./utils/stack";
/** A client for Mezon server. */
export declare class MezonClient implements Client {
    readonly apiKey: string;
    readonly host: string;
    readonly port: string;
    readonly useSSL: boolean;
    readonly timeout: number;
    readonly autoRefreshSession: boolean;
    /** The expired timespan used to check session lifetime. */
    expiredTimespanMs: number;
    /** The low level API client for Nakama server. */
    private readonly apiClient;
    /** the socket */
    private socket;
    /** the session */
    private session;
    private isHardDisconnect;
    [key: string]: any;
    constructor(apiKey?: string, host?: string, port?: string, useSSL?: boolean, timeout?: number, autoRefreshSession?: boolean);
    /** Send message to channel */
    sendMessage(clan_id: string, channel_id: string, mode: number, is_public: boolean, msg: ChannelMessageContent, mentions?: Array<ApiMessageMention>, attachments?: Array<ApiMessageAttachment>, ref?: Array<ApiMessageRef>, anonymous_message?: boolean, mention_everyone?: boolean, avatar?: string, code?: number, topic_id?: string): Promise<import("./interfaces").ChannelMessageAck>;
    /** Send token to user */
    sendToken(sendTokenData: TokenSentEvent): Promise<any>;
    /** React message */
    reactionMessage(id: string, clan_id: string, channel_id: string, mode: number, is_public: boolean, message_id: string, emoji_id: string, emoji: string, count: number, message_sender_id: string, action_delete: boolean): Promise<import("./interfaces").ApiMessageReaction>;
    /** Update message */
    updateChatMessage(clan_id: string, channel_id: string, mode: number, is_public: boolean, message_id: string, content: any, mentions?: Array<ApiMessageMention>, attachments?: Array<ApiMessageAttachment>, hideEditted?: boolean): Promise<import("./interfaces").ChannelMessageAck>;
    /** Join to chat in clan when invited to clan */
    joinClanChat(clan_id: string): Promise<void>;
    /** Authenticate a user with an ID against the server. */
    authenticate(): Promise<string>;
    /** Close socket. */
    closeSocket(): void;
    /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
    sessionRefresh(): Promise<void>;
    /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
    logout(session: Session): Promise<boolean>;
    /** A socket created with the client's configuration. */
    createSocket(useSSL?: boolean, verbose?: boolean, adapter?: WebSocketAdapter, sendTimeoutMs?: number): Socket;
    /**Add handle function to event socket */
    on(event: Events, func: Function, context?: any): void;
    /**remove handle function to event socket */
    remove(event: string, func: Function): void;
    /**Create connect to event socket */
    connectSocket(): Promise<void>;
    onerror(evt: ErrorEvent): void;
    onheartbeattimeout(): void;
    ondisconnect(e: CloseEvent): void;
    retriesConnect(): void;
    createChannelDesc(request: ApiCreateChannelDescRequest): Promise<void | ApiChannelDescription>;
    sleep(ms: number): Promise<unknown>;
    /** Create DM channel to send DM with user */
    createDMchannel(userId: string): Promise<null | ApiChannelDescription>;
    sendBulkMessage(messages: MessagePayLoad[], callback: Function): Stack;
    sendBulkMessageUser(messages: MessageUserPayLoad[], callback: Function): Stack;
    /** Send DM message to user */
    sendDMChannelMessage(channelDmId: string, msg: string, messOptions?: {
        [x: string]: any;
    }, attachments?: Array<ApiMessageAttachment>, refs?: Array<ApiMessageRef>): Promise<import("./interfaces").ChannelMessageAck>;
    /** List a channel's users. */
    listChannelVoiceUsers(clanId: string, channelId: string, channelType: number, limit?: number, state?: number, cursor?: string): Promise<ApiVoiceChannelUserList>;
    /** Register stream channel */
    registerStreamingChannel(request: ApiRegisterStreamingChannelRequest): Promise<any>;
}
