"use strict";
/**
 * Copyright 2020 The Nakama Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MezonClient = void 0;
const api_1 = require("./api");
const session_1 = require("./session");
const socket_1 = require("./socket");
const web_socket_adapter_pb_1 = require("./web_socket_adapter_pb");
const enum_1 = require("./constants/enum");
const helper_1 = require("./utils/helper");
const generate_reply_message_1 = require("./utils/generate_reply_message");
const stack_1 = require("./utils/stack");
const DEFAULT_HOST = "api.mezon.vn";
const DEFAULT_PORT = "443";
const DEFAULT_API_KEY = "";
const DEFAULT_SSL = true;
const DEFAULT_TIMEOUT_MS = 7000;
const DEFAULT_EXPIRED_TIMESPAN_MS = 5 * 60 * 1000;
const DEFAULT_SEND_BULK_INTERVAL = 1000;
const DEFAULT_MESSAGE_PER_TIME = 5;
/** A client for Mezon server. */
class MezonClient {
    constructor(apiKey = DEFAULT_API_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = DEFAULT_SSL, timeout = DEFAULT_TIMEOUT_MS, autoRefreshSession = true) {
        this.apiKey = apiKey;
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.timeout = timeout;
        this.autoRefreshSession = autoRefreshSession;
        /** The expired timespan used to check session lifetime. */
        this.expiredTimespanMs = DEFAULT_EXPIRED_TIMESPAN_MS;
        const scheme = useSSL ? "https://" : "http://";
        const basePath = `${scheme}${host}:${port}`;
        this.apiClient = new api_1.MezonApi(apiKey, basePath, timeout);
        /**init event to connect socket*/
        for (const event in enum_1.Events) {
            const key = enum_1.Events[event].toString();
            if (!(key in this)) {
                this[key] = [];
            }
        }
        this.socket = this.createSocket(this.useSSL, false, new web_socket_adapter_pb_1.WebSocketAdapterPb());
    }
    /** Send message to channel */
    async sendMessage(clan_id, channel_id, mode, is_public, msg, mentions, attachments, ref, anonymous_message, mention_everyone, avatar, code, topic_id) {
        const messageLength = JSON.stringify(msg).length;
        if (messageLength > 4096 * 2)
            throw "Message exceeds allowed characters";
        const msgACK = await this.socket.writeChatMessage(clan_id, channel_id, mode, is_public, msg, mentions, attachments, ref, anonymous_message, mention_everyone, avatar, code, topic_id);
        return msgACK;
    }
    /** Send token to user */
    async sendToken(sendTokenData) {
        const session = this.session;
        return this.apiClient.sendToken(session.token, sendTokenData);
    }
    /** React message */
    async reactionMessage(id, clan_id, channel_id, mode, is_public, message_id, emoji_id, emoji, count, message_sender_id, action_delete) {
        const msgReaction = await this.socket.writeMessageReaction(id, clan_id, channel_id, mode, is_public, message_id, emoji_id, emoji, count, message_sender_id, action_delete);
        return msgReaction;
    }
    /** Update message */
    async updateChatMessage(clan_id, channel_id, mode, is_public, message_id, content, mentions, attachments, hideEditted) {
        const messageLength = JSON.stringify(content).length;
        if (messageLength > 4096 * 2)
            throw "Message exceeds allowed characters";
        const msgUpdated = await this.socket.updateChatMessage(clan_id, channel_id, mode, is_public, message_id, content, mentions, attachments, hideEditted);
        return msgUpdated;
    }
    /** Join to chat in clan when invited to clan */
    async joinClanChat(clan_id) {
        try {
            await this.socket.joinClanChat(clan_id);
        }
        catch (error) {
            throw (error);
        }
    }
    /** Authenticate a user with an ID against the server. */
    async authenticate() {
        return this.apiClient.mezonAuthenticate(this.apiKey, "", {
            account: {
                token: this.apiKey,
            }
        }).then(async (apiSession) => {
            const sockSession = new session_1.Session(apiSession);
            this.session = await this.socket.connect(sockSession, true);
            if (!this.session) {
                return Promise.resolve("error authenticate");
            }
            await this.connectSocket();
            this.isHardDisconnect = false;
            return Promise.resolve("connect successful");
        });
    }
    /** Close socket. */
    closeSocket() {
        console.log("Client sent disconnected.");
        this.isHardDisconnect = true;
        this.socket.close();
    }
    /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
    async sessionRefresh() {
    }
    /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
    async logout(session) {
        const request = {
            "token": session.token,
            "refresh_token": session.refresh_token
        };
        return this.apiClient.mezonAuthenticateLogout(session.token, request).then((response) => {
            return Promise.resolve(response !== undefined);
        });
    }
    /** A socket created with the client's configuration. */
    createSocket(useSSL = false, verbose = false, adapter = new web_socket_adapter_pb_1.WebSocketAdapterPb(), sendTimeoutMs = socket_1.DefaultSocket.DefaultSendTimeoutMs) {
        return new socket_1.DefaultSocket(this.host, this.port, useSSL, verbose, adapter, sendTimeoutMs);
    }
    /**Add handle function to event socket */
    on(event, func, context = null) {
        const key = event;
        if (!(key in this)) {
            throw new Error("Mezon SDK not support this event");
        }
        if (typeof func != "function") {
            throw new Error("Please add function to event");
        }
        const handleFunctions = this[key];
        if (Array.isArray(handleFunctions)) {
            handleFunctions.push(context ? func.bind(context) : func);
        }
    }
    /**remove handle function to event socket */
    remove(event, func) {
        const key = event;
        if (!(key in this)) {
            throw new Error("Mezon SDK not support this event");
        }
        const handleFunctions = this[key];
        if (Array.isArray(handleFunctions)) {
            this[key] = handleFunctions.filter((f) => f != func);
        }
    }
    /**Create connect to event socket */
    async connectSocket() {
        var _a;
        const clans = await this.apiClient.listClanDescs(this.session.token);
        (_a = clans.clandesc) === null || _a === void 0 ? void 0 : _a.forEach(async (clan) => {
            await this.socket.joinClanChat(clan.clan_id || '');
        });
        // join direct message
        await this.socket.joinClanChat("0");
        ["ondisconnect", "onerror", "onheartbeattimeout"].forEach((event) => {
            this.socket[event] = this[event].bind(this);
        });
        for (const event in enum_1.Events) {
            const key = enum_1.Events[event].toString();
            this.socket.socketEvents.on(key, (...args) => {
                const handleFunctions = this[key];
                if (Array.isArray(handleFunctions)) {
                    handleFunctions.forEach((func) => {
                        if (typeof func == "function") {
                            Promise.resolve(func(...args)).catch((err) => {
                                if (func.toString().includes(" this.")) {
                                    console.log(`Please using arrow function for function ${func.name} or add event with context with sync like .on('event', callback, this) pass 'this variable' in to get context`);
                                }
                                console.log(err);
                            });
                        }
                    });
                }
            });
        }
    }
    onerror(evt) {
        console.log(evt);
        if (this.isHardDisconnect)
            return;
        if (this.socket.isOpen()) {
            this.retriesConnect();
        }
    }
    onheartbeattimeout() {
        console.log("Heartbeat timeout.");
    }
    ondisconnect(e) {
        console.log("Disconnected!", e === null || e === void 0 ? void 0 : e.reason);
        if (this.isHardDisconnect)
            return;
        this.retriesConnect();
    }
    retriesConnect() {
        let retryInterval = 5000; // Initial wait time in milliseconds
        const maxRetryInterval = 60000; // Maximum wait time (60 seconds)
        console.log("Reconnecting...");
        const interval = setInterval(async () => {
            try {
                this.socket = this.createSocket(this.useSSL, false, new web_socket_adapter_pb_1.WebSocketAdapterPb());
                await this.authenticate();
                clearInterval(interval); // Clear the interval on success
                console.log("Connected successfully!");
                retryInterval = 5000; // Reset the interval on successful connection
            }
            catch (e) {
                console.log("Connection failed:", e);
                retryInterval = Math.min(retryInterval * 2, maxRetryInterval); // Double the interval, max at 32 seconds
                // Clear the current interval and restart with the new retry interval
                clearInterval(interval);
                setTimeout(() => {
                    this.retriesConnect(); // Restart the connection attempt
                }, retryInterval);
            }
        }, retryInterval);
    }
    async createChannelDesc(request) {
        if (!this.session)
            return;
        const session = this.session;
        if (this.autoRefreshSession &&
            session.refresh_token &&
            session.isexpired(Date.now() / 1000)) {
            await this.sessionRefresh();
        }
        return this.apiClient
            .createChannelDesc(session.token, request);
    }
    async sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    /** Create DM channel to send DM with user */
    async createDMchannel(userId) {
        try {
            if (!(0, helper_1.isValidUserId)(userId))
                return null;
            const request = {
                clan_id: "",
                channel_id: "0",
                category_id: "0",
                type: enum_1.ChannelType.CHANNEL_TYPE_DM,
                user_ids: [userId],
                channel_private: 1,
            };
            const channelDM = await this.createChannelDesc(request);
            if (channelDM) {
                await this.sleep(100);
                await this.socket.joinChat(channelDM.clan_id, channelDM.channel_id, channelDM.type, false);
                return channelDM;
            }
            return null;
        }
        catch (e) {
            console.log(e);
            return null;
        }
    }
    sendBulkMessage(messages, callback) {
        const stack = new stack_1.Stack(DEFAULT_MESSAGE_PER_TIME, DEFAULT_SEND_BULK_INTERVAL, this, callback);
        stack.push(messages);
        return stack;
    }
    sendBulkMessageUser(messages, callback) {
        const stack = new stack_1.Stack(DEFAULT_MESSAGE_PER_TIME, DEFAULT_SEND_BULK_INTERVAL, this, callback, true);
        stack.push(messages);
        return stack;
    }
    /** Send DM message to user */
    async sendDMChannelMessage(channelDmId, msg, messOptions = {}, attachments = [], refs = []) {
        const messageLength = JSON.stringify(msg).length +
            JSON.stringify(messOptions).length;
        if (messageLength > 4096 * 2)
            throw "Message exceeds allowed characters";
        try {
            const message = {
                clan_id: "",
                channel_id: channelDmId,
                is_public: false,
                mode: (0, helper_1.convertChanneltypeToChannelMode)(enum_1.ChannelType.CHANNEL_TYPE_DM),
                mentions: [],
                attachments: attachments,
                ref: [],
            };
            const mess = (0, generate_reply_message_1.replyMessageGenerate)(Object.assign(Object.assign({ messageContent: msg }, messOptions), { attachments, refs }), message);
            return this.sendMessage(mess.clan_id, mess.channel_id, mess.mode, mess.is_public, mess.msg, [], mess.attachments, refs);
        }
        catch (error) {
            throw Error(`Can't send message channel DM`);
        }
    }
    /** List a channel's users. */
    async listChannelVoiceUsers(clanId, channelId, channelType, limit = 500, state, cursor) {
        if (limit <= 0 || limit > 500) {
            console.log("0 < limit <= 500");
            throw Error("0 < limit <= 500");
        }
        const session = this.session;
        if (this.autoRefreshSession &&
            session.refresh_token &&
            session.isexpired(Date.now() / 1000)) {
            await this.sessionRefresh();
        }
        return this.apiClient
            .listChannelVoiceUsers(session.token, clanId, channelId, channelType, limit, state, cursor)
            .then((response) => {
            var result = {
                voice_channel_users: [],
            };
            if (response.voice_channel_users == null) {
                return Promise.resolve(result);
            }
            response.voice_channel_users.forEach((gu) => {
                result.voice_channel_users.push({
                    id: gu.id,
                    channel_id: gu.channel_id,
                    user_id: gu.user_id,
                    participant: gu.participant,
                });
            });
            return Promise.resolve(result);
        });
    }
    /** Register stream channel */
    async registerStreamingChannel(request) {
        const session = this.session;
        if (this.autoRefreshSession &&
            session.refresh_token &&
            session.isexpired(Date.now() / 1000)) {
            await this.sessionRefresh();
        }
        return this.apiClient
            .registerStreamingChannel(session.token, request);
    }
}
exports.MezonClient = MezonClient;
;
//# sourceMappingURL=client.js.map