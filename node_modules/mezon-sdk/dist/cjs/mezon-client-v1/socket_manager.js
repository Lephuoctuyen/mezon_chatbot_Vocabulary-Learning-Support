"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketManager = void 0;
const socket_1 = require("../socket");
const constants_1 = require("../constants");
const web_socket_adapter_pb_1 = require("../web_socket_adapter_pb");
class SocketManager {
    constructor(host, port, useSSL, adapter, sessionManager, apiClient, apiKey, eventManager) {
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.adapter = adapter;
        this.sessionManager = sessionManager;
        this.apiClient = apiClient;
        this.apiKey = apiKey;
        this.eventManager = eventManager;
        this.socket = new socket_1.DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    createSocket() {
        this.adapter = new web_socket_adapter_pb_1.WebSocketAdapterPb();
        this.socket = new socket_1.DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    getSocket() {
        return this.socket;
    }
    async connect(sockSession) {
        const session = await this.socket.connect(sockSession, true);
        this.isHardDisconnect = false;
        return session;
    }
    closeSocket() {
        this.isHardDisconnect = true;
        this.socket.close();
    }
    isOpen() {
        return this.socket.isOpen();
    }
    async onerror(evt) {
        console.log("onerror", evt);
        if (this.isHardDisconnect)
            return;
        if (this.socket.isOpen()) {
            await this.retriesConnect();
        }
    }
    onheartbeattimeout() {
        console.log("Heartbeat timeout.");
    }
    ondisconnect(e) {
        console.log("Disconnected!", e === null || e === void 0 ? void 0 : e.reason);
        if (this.isHardDisconnect)
            return;
        this.retriesConnect();
    }
    async connectSocket(sessionToken) {
        var _a;
        const clans = await this.apiClient.listClanDescs(sessionToken);
        (_a = clans.clandesc) === null || _a === void 0 ? void 0 : _a.forEach(async (clan) => {
            await this.socket.joinClanChat(clan.clan_id || "");
        });
        // join direct message
        await this.socket.joinClanChat("0");
        ["ondisconnect", "onerror", "onheartbeattimeout"].forEach((event) => {
            this.socket[event] = this[event].bind(this);
        });
        for (const event in constants_1.Events) {
            const key = constants_1.Events[event].toString();
            this.socket.socketEvents.on(key, (...args) => {
                this.eventManager.emit(key, ...args);
            });
        }
    }
    async retriesConnect() {
        let retryInterval = 5000;
        const maxRetryInterval = 60000;
        console.log("Reconnecting...");
        const interval = setInterval(async () => {
            try {
                this.createSocket();
                const sockSession = await this.sessionManager.authenticate(this.apiKey);
                const sessionConnected = await this.connect(sockSession);
                if (sessionConnected === null || sessionConnected === void 0 ? void 0 : sessionConnected.token) {
                    await this.connectSocket(sessionConnected.token);
                }
                console.log("Connected successfully!");
                clearInterval(interval);
            }
            catch (e) {
                console.log("Connection failed:", e);
                retryInterval = Math.min(retryInterval * 2, maxRetryInterval);
                console.log(`Retrying in ${retryInterval / 1000} seconds...`);
                clearInterval(interval);
                setTimeout(() => this.retriesConnect(), retryInterval);
            }
        }, retryInterval);
    }
}
exports.SocketManager = SocketManager;
//# sourceMappingURL=socket_manager.js.map