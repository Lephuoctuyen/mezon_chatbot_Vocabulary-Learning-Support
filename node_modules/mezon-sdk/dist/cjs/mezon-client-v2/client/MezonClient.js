"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MezonClient = void 0;
// src/client/MezonClient.ts
const events_1 = require("events");
const CacheManager_1 = require("../utils/CacheManager");
const TextChannel_1 = require("../structures/TextChannel");
// import { User } from "../structures/User";
const Message_1 = require("../structures/Message");
const api_1 = require("../../api");
const socket_manager_1 = require("../manager/socket_manager");
const session_manager_1 = require("../manager/session_manager");
const event_manager_1 = require("../manager/event_manager");
const web_socket_adapter_pb_1 = require("../../web_socket_adapter_pb");
const constants_1 = require("../../constants");
const helper_1 = require("../../utils/helper");
const channel_manager_1 = require("../manager/channel_manager");
const User_1 = require("../structures/User");
const AsyncThrottleQueue_1 = require("../utils/AsyncThrottleQueue");
const DEFAULT_HOST = "api.mezon.vn";
const DEFAULT_PORT = "443";
const DEFAULT_API_KEY = "";
const DEFAULT_SSL = true;
const DEFAULT_TIMEOUT_MS = 7000;
class MezonClient extends events_1.EventEmitter {
    constructor(token = DEFAULT_API_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = DEFAULT_SSL, timeout = DEFAULT_TIMEOUT_MS) {
        super();
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.timeout = timeout;
        this.messageQueue = new AsyncThrottleQueue_1.AsyncThrottleQueue();
        const scheme = useSSL ? "https://" : "http://";
        const basePath = `${scheme}${host}:${port}`;
        this.token = token;
        this.apiClient = new api_1.MezonApi(token, basePath, timeout);
        // this.users = new CacheManager(this._fetchUserFromAPI.bind(this)); // TODO: add user
        this.clans = new CacheManager_1.CacheManager(this._fetchClanFromAPI.bind(this));
        this.channels = new CacheManager_1.CacheManager(this._fetchChannelFromAPI.bind(this));
        this.sessionManager = new session_manager_1.SessionManager(this.apiClient);
        this.eventManager = new event_manager_1.EventManager();
        this.socketManager = new socket_manager_1.SocketManager(this.host, this.port, this.useSSL, new web_socket_adapter_pb_1.WebSocketAdapterPb(), this.sessionManager, this.apiClient, this.token, this.eventManager, this.messageQueue, this);
        this.channelManager = new channel_manager_1.ChannelManager(this.apiClient, this.socketManager, this.sessionManager);
    }
    /** Login bot */
    async login() {
        const sockSession = await this.sessionManager.authenticate(this.token);
        this.clientId = sockSession === null || sockSession === void 0 ? void 0 : sockSession.user_id;
        const sessionConnected = await this.socketManager.connect(sockSession);
        if (sessionConnected === null || sessionConnected === void 0 ? void 0 : sessionConnected.token) {
            await this.socketManager.connectSocket(sessionConnected.token);
            await this.channelManager.initAllDmChannels(sessionConnected.token);
        }
        this.emit("ready");
        return "Authenticate success!";
    }
    /** Create DM channel */
    async createDMchannel(userId) {
        try {
            if (!(0, helper_1.isValidUserId)(userId))
                return null;
            const socket = this.socketManager.getSocket();
            const request = {
                clan_id: "",
                channel_id: "0",
                category_id: "0",
                type: constants_1.ChannelType.CHANNEL_TYPE_DM,
                user_ids: [userId],
                channel_private: 1,
            };
            const channelDM = await this.apiClient.createChannelDesc(this.sessionManager.getSession().token, request);
            if (channelDM) {
                await (0, helper_1.sleep)(100);
                await socket.joinChat(channelDM.clan_id, channelDM.channel_id, channelDM.type, false);
                return channelDM;
            }
            return null;
        }
        catch (e) {
            console.log(e);
            return null;
        }
    }
    async sendToken(sendTokenData) {
        const session = this.sessionManager.getSession();
        return this.apiClient.sendToken(session.token, sendTokenData);
    }
    /** Listen to messages user sends on the  channel, thread */
    async onChannelMessage(listener) {
        this.on(constants_1.Events.ChannelMessage.toString(), async (e) => {
            // handle init cache channel, message, user
            await this._initChannelMessageCache(e);
            await this._initUserClanCache(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel created */
    onChannelCreated(listener) {
        this.on(constants_1.Events.ChannelCreated.toString(), async (e) => {
            this._updateCacheChannel(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel updated */
    onChannelUpdated(listener) {
        this.on(constants_1.Events.ChannelUpdated.toString(), async (e) => {
            if (e.channel_type === constants_1.ChannelType.CHANNEL_TYPE_THREAD &&
                e.status === 1) {
                const socket = this.socketManager.getSocket();
                await socket.joinChat(e.clan_id, e.channel_id, e.channel_type, false);
            }
            this._updateCacheChannel(e);
            listener(e);
        });
        return this;
    }
    /** Listen to channel deleted */
    onChannelDeleted(listener) {
        this.on(constants_1.Events.ChannelDeleted.toString(), async (e) => {
            const clan = this.clans.get(e.clan_id);
            if (!clan)
                return;
            this.channels.delete(e.channel_id);
            clan.channels.delete(e.channel_id);
            listener(e);
        });
        return this;
    }
    /** Listen to user send token to each other */
    onTokenSend(listener) {
        this.on(constants_1.Events.TokenSend.toString(), listener);
        return this;
    }
    /** Listen to user react to messages on the channel, thread */
    onMessageReaction(listener) {
        this.on(constants_1.Events.MessageReaction.toString(), listener);
        return this;
    }
    /** Listen to user react to messages on the channel, thread */
    onUserChannelRemoved(listener) {
        this.on(constants_1.Events.UserChannelRemoved.toString(), listener);
        return this;
    }
    /** Listen to user leaved/removed in the channel */
    onUserClanRemoved(listener) {
        this.on(constants_1.Events.UserClanRemoved.toString(), async (e) => {
            const clan = this.clans.get(e.clan_id);
            if (!clan)
                return;
            e.user_ids.forEach((user_id) => {
                clan.users.delete(user_id);
            });
            listener(e);
        });
        return this;
    }
    /** Listen to user added in the channel */
    onUserChannelAdded(listener) {
        this.on(constants_1.Events.UserChannelAdded.toString(), async (e) => {
            var _a;
            const socket = this.socketManager.getSocket();
            if ((_a = e === null || e === void 0 ? void 0 : e.users) === null || _a === void 0 ? void 0 : _a.some((user) => user.user_id == this.clientId)) {
                await socket.joinChat(e.clan_id, e.channel_desc.channel_id, e.channel_desc.type, !e.channel_desc.channel_private);
            }
            listener(e);
        });
        return this;
    }
    /** Listen to users give coffee to each other */
    onGiveCoffee(listener) {
        this.on(constants_1.Events.GiveCoffee.toString(), listener);
        return this;
    }
    /** Listen to clan create new role */
    onRoleEvent(listener) {
        this.on(constants_1.Events.RoleEvent.toString(), listener);
        return this;
    }
    /** Listen to assigning a role to user */
    onRoleAssign(listener) {
        this.on(constants_1.Events.RoleAssign.toString(), listener);
        return this;
    }
    /** Listen to user added in CLAN */
    onAddClanUser(listener) {
        this.on(constants_1.Events.AddClanUser.toString(), listener);
        return this;
    }
    /** Listen to clan create a new event */
    onClanEventCreated(listener) {
        this.on(constants_1.Events.ClanEventCreated.toString(), listener);
        return this;
    }
    /** Listen to user lick a button on embed message */
    onMessageButtonClicked(listener) {
        this.on(constants_1.Events.MessageButtonClicked.toString(), listener);
        return this;
    }
    /** Listen to user joined a stream room */
    onStreamingJoinedEvent(listener) {
        this.on(constants_1.Events.StreamingJoinedEvent.toString(), listener);
        return this;
    }
    /** Listen to user leaved a stream room */
    onStreamingLeavedEvent(listener) {
        this.on(constants_1.Events.StreamingLeavedEvent.toString(), listener);
        return this;
    }
    /** Listen to user selected a input dropdown */
    onDropdownBoxSelected(listener) {
        this.on(constants_1.Events.DropdownBoxSelected.toString(), listener);
        return this;
    }
    /** Listen to user accepted call 1-1 */
    onWebrtcSignalingFwd(listener) {
        this.on(constants_1.Events.WebrtcSignalingFwd.toString(), listener);
        return this;
    }
    closeSocket() {
        this.socketManager.closeSocket();
        this.eventManager = new event_manager_1.EventManager(); // Reset event manager
    }
    async _fetchClanFromAPI(id) {
        throw Error(`Can not find clan ${id}!`);
    }
    async _fetchChannelFromAPI(id) {
        var _a;
        console.log("_fetchChannelFromAPI", id);
        const session = this.sessionManager.getSession();
        const channelDetail = await this.apiClient.listChannelDetail(session.token, id);
        if (!(channelDetail === null || channelDetail === void 0 ? void 0 : channelDetail.clan_id) || (channelDetail === null || channelDetail === void 0 ? void 0 : channelDetail.clan_id) === "0") {
            throw Error(`Cannot fetch channelDM ${(_a = channelDetail === null || channelDetail === void 0 ? void 0 : channelDetail.channel_id) !== null && _a !== void 0 ? _a : ""}!`);
        }
        const clanId = channelDetail.clan_id;
        const clan = this.clans.get(clanId);
        const channel = new TextChannel_1.TextChannel(channelDetail, clan, this.socketManager, this.messageQueue);
        this.channels.set(channel.id, channel);
        clan.channels.set(channel.id, channel);
        return channel;
    }
    async _initChannelMessageCache(e) {
        const { clan_id, channel_id, sender_id, message_id, content, reactions, mentions, attachments, references, } = e;
        if (!clan_id || clan_id === "0")
            return;
        const clan = this.clans.get(clan_id);
        if (!clan)
            return;
        await clan.loadChannels();
        const channel = await this.channels.fetch(channel_id);
        const messageRaw = {
            id: message_id,
            clan_id: clan_id,
            channel_id: channel_id,
            sender_id: sender_id,
            content,
            reactions,
            mentions,
            attachments,
            references,
        };
        const message = new Message_1.Message(messageRaw, channel, this.socketManager, this.messageQueue);
        channel.messages.set(message_id, message);
    }
    async _initUserClanCache(e) {
        var _a, _b;
        const { clan_id, sender_id, username, clan_nick, clan_avatar, avatar, display_name, } = e;
        const clan = this.clans.get(clan_id);
        if (clan) {
            let userCache = clan.users.get(sender_id);
            let dmChannelId = (_a = userCache === null || userCache === void 0 ? void 0 : userCache.dmChannelId) !== null && _a !== void 0 ? _a : "";
            if (!userCache && sender_id !== this.clientId) {
                const allDmChannel = this.channelManager.getAllDmChannels();
                dmChannelId = (_b = allDmChannel === null || allDmChannel === void 0 ? void 0 : allDmChannel[sender_id]) !== null && _b !== void 0 ? _b : "";
            }
            const userRaw = {
                id: sender_id,
                username: username,
                clan_nick: clan_nick,
                clan_avatar: clan_avatar,
                avartar: avatar,
                display_name: display_name,
                dmChannelId,
            };
            const user = new User_1.User(userRaw, clan, this.channelManager);
            clan.users.set(sender_id, user);
        }
    }
    _updateCacheChannel(e) {
        const clan = this.clans.get(e.clan_id);
        if (!clan)
            return;
        const channelObj = new TextChannel_1.TextChannel(Object.assign(Object.assign({}, e), { type: e.channel_type, channel_private: e.channel_private ? 1 : 0 }), clan, this.socketManager, this.messageQueue);
        this.channels.set(e.channel_id, channelObj);
        clan.channels.set(e.channel_id, channelObj);
        this.socketManager.getSocket().joinChat;
    }
}
exports.MezonClient = MezonClient;
//# sourceMappingURL=MezonClient.js.map