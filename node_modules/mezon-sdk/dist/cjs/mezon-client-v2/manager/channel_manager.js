"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelManager = void 0;
const constants_1 = require("../../constants");
const helper_1 = require("../../utils/helper");
class ChannelManager {
    constructor(apiClient, socketManager, sessionManager) {
        this.apiClient = apiClient;
        this.socketManager = socketManager;
        this.sessionManager = sessionManager;
    }
    async initAllDmChannels(sessionToken) {
        if (!sessionToken)
            return;
        const channels = await this.apiClient.listChannelDescs(sessionToken, constants_1.ChannelType.CHANNEL_TYPE_DM);
        this.allDmChannels = channels === null || channels === void 0 ? void 0 : channels.channeldesc.map((channel) => {
            var _a;
            if (!((_a = channel === null || channel === void 0 ? void 0 : channel.user_id) === null || _a === void 0 ? void 0 : _a.length))
                return;
            return {
                [channel.user_id[0]]: channel.channel_id,
            };
        }).filter(Boolean).reduce((acc, curr) => Object.assign(acc, curr), {});
    }
    getAllDmChannels() {
        return this.allDmChannels;
    }
    /** Create DM channel with user */
    async createDMchannel(userId) {
        try {
            if (!(0, helper_1.isValidUserId)(userId))
                return null;
            const socket = this.socketManager.getSocket();
            const request = {
                clan_id: "",
                channel_id: "0",
                category_id: "0",
                type: constants_1.ChannelType.CHANNEL_TYPE_DM,
                user_ids: [userId],
                channel_private: 1,
            };
            const channelDM = await this.apiClient.createChannelDesc(this.sessionManager.getSession().token, request);
            if (channelDM) {
                await this.sleep(100);
                await socket.joinChat(channelDM.clan_id, channelDM.channel_id, channelDM.type, false);
                return channelDM;
            }
            return null;
        }
        catch (e) {
            console.log(e);
            return null;
        }
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
exports.ChannelManager = ChannelManager;
//# sourceMappingURL=channel_manager.js.map