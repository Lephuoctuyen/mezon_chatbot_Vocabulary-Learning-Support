"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketManager = void 0;
const constants_1 = require("../../constants");
const socket_1 = require("../../socket");
const web_socket_adapter_pb_1 = require("../../web_socket_adapter_pb");
const Clan_1 = require("../structures/Clan");
const helper_1 = require("../../utils/helper");
class SocketManager {
    constructor(host, port, useSSL, adapter, apiClient, eventManager, messageQueue, client, messageDB) {
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.adapter = adapter;
        this.apiClient = apiClient;
        this.eventManager = eventManager;
        this.messageQueue = messageQueue;
        this.client = client;
        this.messageDB = messageDB;
        this.isRetrying = false;
        this.socket = new socket_1.DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    createSocket() {
        this.adapter = new web_socket_adapter_pb_1.WebSocketAdapterPb();
        this.socket = new socket_1.DefaultSocket(this.host, this.port, this.useSSL, false, this.adapter);
    }
    getSocket() {
        return this.socket;
    }
    async connect(sockSession) {
        this.isHardDisconnect = false;
        const session = await this.socket.connect(sockSession, true);
        return session;
    }
    closeSocket() {
        this.isHardDisconnect = true;
        this.socket.close();
        console.log("eventManager", this.eventManager);
    }
    isOpen() {
        return this.socket.isOpen();
    }
    async onerror(evt) {
        console.log("onerror", evt);
        if (this.isHardDisconnect)
            return;
        if (this.socket.isOpen()) {
            await this.retriesConnect();
        }
    }
    onheartbeattimeout() {
        console.log("Heartbeat timeout.");
    }
    ondisconnect(e) {
        console.log("Disconnected!", e === null || e === void 0 ? void 0 : e.reason);
        if (this.isHardDisconnect)
            return;
        this.retriesConnect();
    }
    async connectSocket(sessionToken) {
        var _a;
        const clans = await this.apiClient.listClanDescs(sessionToken);
        const clanList = (_a = clans === null || clans === void 0 ? void 0 : clans.clandesc) !== null && _a !== void 0 ? _a : [];
        clanList.push({ clan_id: "0", clan_name: "" });
        clanList.forEach(async (clan) => {
            var _a, _b;
            await this.socket.joinClanChat(clan.clan_id || "");
            if (!this.client.clans.get(clan.clan_id)) {
                const clanObj = new Clan_1.Clan({
                    id: clan.clan_id,
                    name: (_a = clan === null || clan === void 0 ? void 0 : clan.clan_name) !== null && _a !== void 0 ? _a : "unknown",
                    welcome_channel_id: (_b = clan === null || clan === void 0 ? void 0 : clan.welcome_channel_id) !== null && _b !== void 0 ? _b : ''
                }, this.client, this.apiClient, this, sessionToken, this.messageQueue, this.messageDB);
                this.client.clans.set(clan.clan_id, clanObj);
            }
        });
        // join direct message
        await this.socket.joinClanChat("0");
        ["ondisconnect", "onerror", "onheartbeattimeout"].forEach((event) => {
            this.socket[event] = this[event].bind(this);
        });
        for (const event in constants_1.Events) {
            const key = constants_1.Events[event].toString();
            this.socket.socketEvents.on(key, (...args) => {
                this.client.emit(key, ...args);
            });
        }
    }
    async retriesConnect() {
        if (this.isRetrying)
            return;
        this.isRetrying = true;
        let retryInterval = 5000;
        const maxRetryInterval = 60000;
        console.log("Reconnecting...");
        const retry = async () => {
            try {
                await this.client.login();
                this.isRetrying = false;
                console.log("Connected successfully!");
            }
            catch (e) {
                console.log("Connection failed!", e);
                retryInterval = Math.min(retryInterval * 2, maxRetryInterval);
                console.log(`Retrying in ${retryInterval / 1000} seconds...`);
                setTimeout(retry, retryInterval);
            }
        };
        retry();
    }
    async writeChatMessage(dataWriteMessage) {
        var _a, _b, _c;
        try {
            const msgACK = await this.socket.writeChatMessage(dataWriteMessage.clan_id, dataWriteMessage.channel_id, dataWriteMessage.mode, dataWriteMessage.is_public, dataWriteMessage.content, (_a = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.mentions) !== null && _a !== void 0 ? _a : [], (_b = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.attachments) !== null && _b !== void 0 ? _b : [], (_c = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.references) !== null && _c !== void 0 ? _c : [], dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.anonymous_message, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.mention_everyone, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.avatar, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.code, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.topic_id);
            return msgACK;
        }
        catch (error) {
            throw error;
        }
    }
    async writeEphemeralMessage(dataWriteMessage) {
        var _a, _b, _c;
        try {
            const msgACK = await this.socket.writeEphemeralMessage(dataWriteMessage.receiver_id, dataWriteMessage.clan_id, dataWriteMessage.channel_id, dataWriteMessage.mode, dataWriteMessage.is_public, dataWriteMessage.content, (_a = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.mentions) !== null && _a !== void 0 ? _a : [], (_b = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.attachments) !== null && _b !== void 0 ? _b : [], (_c = dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.references) !== null && _c !== void 0 ? _c : [], dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.anonymous_message, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.mention_everyone, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.avatar, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.code, dataWriteMessage === null || dataWriteMessage === void 0 ? void 0 : dataWriteMessage.topic_id);
            return msgACK;
        }
        catch (error) {
            throw error;
        }
    }
    async updateChatMessage(dataUpdateMessage) {
        var _a, _b, _c;
        try {
            await (0, helper_1.sleep)(1000);
            const msgACK = await this.socket.updateChatMessage(dataUpdateMessage.clan_id, dataUpdateMessage.channel_id, dataUpdateMessage.mode, dataUpdateMessage.is_public, dataUpdateMessage.message_id, dataUpdateMessage.content, (_a = dataUpdateMessage === null || dataUpdateMessage === void 0 ? void 0 : dataUpdateMessage.mentions) !== null && _a !== void 0 ? _a : [], (_b = dataUpdateMessage === null || dataUpdateMessage === void 0 ? void 0 : dataUpdateMessage.attachments) !== null && _b !== void 0 ? _b : [], (_c = dataUpdateMessage === null || dataUpdateMessage === void 0 ? void 0 : dataUpdateMessage.hideEditted) !== null && _c !== void 0 ? _c : false, dataUpdateMessage === null || dataUpdateMessage === void 0 ? void 0 : dataUpdateMessage.topic_id);
            return msgACK;
        }
        catch (error) {
            throw error;
        }
    }
    async writeMessageReaction(dataReactionMessage) {
        var _a, _b;
        try {
            const msgACK = await this.socket.writeMessageReaction((_a = dataReactionMessage.id) !== null && _a !== void 0 ? _a : "", dataReactionMessage.clan_id, dataReactionMessage.channel_id, dataReactionMessage.mode, dataReactionMessage.is_public, dataReactionMessage.message_id, dataReactionMessage.emoji_id, dataReactionMessage.emoji, dataReactionMessage.count, dataReactionMessage.message_sender_id, (_b = dataReactionMessage === null || dataReactionMessage === void 0 ? void 0 : dataReactionMessage.action_delete) !== null && _b !== void 0 ? _b : false);
            return msgACK;
        }
        catch (error) {
            throw error;
        }
    }
    async removeChatMessage(dataRemoveMessage) {
        try {
            const msgACK = await this.socket.removeChatMessage(dataRemoveMessage.clan_id, dataRemoveMessage.channel_id, dataRemoveMessage.mode, dataRemoveMessage.is_public, dataRemoveMessage.message_id);
            return msgACK;
        }
        catch (error) {
            throw error;
        }
    }
}
exports.SocketManager = SocketManager;
//# sourceMappingURL=socket_manager.js.map