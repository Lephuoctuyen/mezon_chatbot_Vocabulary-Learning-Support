"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextChannel = void 0;
const helper_1 = require("../../utils/helper");
const CacheManager_1 = require("../utils/CacheManager");
const Message_1 = require("./Message");
class TextChannel {
    constructor(initChannelData, clan, socketManager, messageQueue, messageDB) {
        var _a, _b, _c;
        this.id = initChannelData.channel_id;
        this.name = initChannelData.channel_label;
        this.channel_type = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.type;
        this.is_private = !!(initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.channel_private);
        this.category_id = (_a = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.category_id) !== null && _a !== void 0 ? _a : "";
        this.category_name = (_b = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.category_name) !== null && _b !== void 0 ? _b : "";
        this.parent_id = (_c = initChannelData === null || initChannelData === void 0 ? void 0 : initChannelData.parent_id) !== null && _c !== void 0 ? _c : "";
        this.clan = clan;
        this.messages = new CacheManager_1.CacheManager(async (message_id) => {
            const messageDb = this.messageDB.getMessageById(message_id, this.id);
            if (!messageDb) {
                throw Error(`Message ${message_id} not found on channel ${this.id}!`);
            }
            const newMessage = new Message_1.Message(messageDb, this, this.socketManager, this.messageQueue);
            return newMessage;
        }, 200);
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
        this.messageDB = messageDB;
    }
    async send(content, mentions, attachments, mention_everyone, anonymous_message, topic_id, code) {
        return this.messageQueue.enqueue(async () => {
            const dataSend = {
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: (0, helper_1.convertChanneltypeToChannelMode)(this.channel_type),
                is_public: !this.is_private,
                content,
                mentions,
                attachments,
                anonymous_message,
                mention_everyone,
                code,
                topic_id,
            };
            return await this.socketManager.writeChatMessage(dataSend);
        });
    }
    async sendEphemeral(receiver_id, content, reference_message_id, mentions, attachments, mention_everyone, anonymous_message, topic_id, code) {
        return this.messageQueue.enqueue(async () => {
            let references = [];
            if (reference_message_id) {
                let messageRef = await this.messages.fetch(reference_message_id);
                const user = await this.clan.users.fetch(messageRef.sender_id);
                references = [
                    {
                        message_ref_id: messageRef.id,
                        message_sender_id: messageRef.sender_id,
                        message_sender_username: user.clan_nick || user.display_name || user.username,
                        mesages_sender_avatar: user.clan_avatar || user.avartar,
                        content: JSON.stringify(messageRef.content),
                    },
                ];
            }
            const dataSend = {
                receiver_id,
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: (0, helper_1.convertChanneltypeToChannelMode)(this.channel_type),
                is_public: !this.is_private,
                content,
                mentions,
                attachments,
                references: references !== null && references !== void 0 ? references : [],
                anonymous_message,
                mention_everyone,
                code,
                topic_id,
            };
            return await this.socketManager.writeEphemeralMessage(dataSend);
        });
    }
}
exports.TextChannel = TextChannel;
//# sourceMappingURL=TextChannel.js.map