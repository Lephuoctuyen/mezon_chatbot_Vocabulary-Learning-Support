"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageDatabase = void 0;
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
class MessageDatabase {
    constructor(dbPath = "./mezon-cache/mezon-messages-cache.db") {
        const dir = path_1.default.dirname(dbPath);
        if (!fs_1.default.existsSync(dir)) {
            fs_1.default.mkdirSync(dir, { recursive: true });
        }
        this.ensureGitIgnore(dbPath);
        this.db = new better_sqlite3_1.default(dbPath);
        this.init();
    }
    ensureGitIgnore(dbPath) {
        const gitignorePath = path_1.default.resolve(".gitignore");
        const dirName = path_1.default.dirname(dbPath);
        let relativeDir = dirName.replace(/\\/g, "/");
        if (relativeDir.startsWith("./")) {
            relativeDir = relativeDir.slice(2);
        }
        try {
            let gitignoreContent = "";
            if (fs_1.default.existsSync(gitignorePath)) {
                gitignoreContent = fs_1.default.readFileSync(gitignorePath, "utf-8");
            }
            if (!gitignoreContent.includes(relativeDir)) {
                fs_1.default.appendFileSync(gitignorePath, `\n# Mezon cache\n/${relativeDir}`);
                console.log(`[mezon] Added "${relativeDir}" to .gitignore`);
            }
        }
        catch (err) {
            console.warn("[mezon] Could not modify .gitignore:", err);
        }
    }
    init() {
        this.db
            .prepare(`CREATE TABLE IF NOT EXISTS messages (
        id TEXT PRIMARY KEY,
        clan_id TEXT,
        channel_id TEXT,
        sender_id TEXT,
        content TEXT,
        mentions TEXT,
        attachments TEXT,
        reactions TEXT,
        msg_references TEXT,
        topic_id TEXT,
        create_time_seconds INTEGER
      )`)
            .run();
        this.db
            .prepare(`CREATE INDEX IF NOT EXISTS idx_channel_id_id ON messages(channel_id, id)`)
            .run();
    }
    saveMessage(message) {
        var _a, _b, _c, _d, _e, _f, _g;
        const stmt = this.db.prepare(`INSERT OR REPLACE INTO messages (
        id, clan_id, channel_id, sender_id,
        content, mentions, attachments, reactions,
        msg_references, topic_id, create_time_seconds
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`);
        stmt.run(message.message_id, message.clan_id, message.channel_id, message.sender_id, JSON.stringify((_a = message.content) !== null && _a !== void 0 ? _a : {}), JSON.stringify((_b = message.mentions) !== null && _b !== void 0 ? _b : []), JSON.stringify((_c = message.attachments) !== null && _c !== void 0 ? _c : []), JSON.stringify((_d = message.reactions) !== null && _d !== void 0 ? _d : []), JSON.stringify((_e = message.references) !== null && _e !== void 0 ? _e : []), (_f = message.topic_id) !== null && _f !== void 0 ? _f : null, (_g = message.create_time_seconds) !== null && _g !== void 0 ? _g : null);
    }
    getMessageById(messageId, channelId) {
        const stmt = this.db.prepare(`SELECT * FROM messages WHERE channel_id = ? AND id = ? LIMIT 1`);
        const row = stmt.get(channelId, messageId);
        if (!row)
            return null;
        return Object.assign(Object.assign({}, row), { content: JSON.parse(row.content), mentions: JSON.parse(row.mentions), attachments: JSON.parse(row.attachments), reactions: JSON.parse(row.reactions), references: JSON.parse(row.msg_references) });
    }
}
exports.MessageDatabase = MessageDatabase;
//# sourceMappingURL=MessageDatabase.js.map