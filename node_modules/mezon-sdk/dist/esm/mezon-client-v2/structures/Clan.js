import { ChannelType } from "../../constants";
import { CacheManager } from "../utils/CacheManager";
import { TextChannel } from "./TextChannel";
export class Clan {
    id;
    name;
    channels;
    users;
    sessionToken;
    apiClient;
    // cache status load channel
    _channelsLoaded = false;
    // cache status load channel call api
    _loadingPromise = null;
    client;
    socketManager;
    messageQueue;
    constructor(initClanData, client, apiClient, socketManager, sessionToken, messageQueue) {
        this.id = initClanData.id;
        this.name = initClanData.name;
        this.client = client;
        this.apiClient = apiClient;
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
        this.sessionToken = sessionToken;
        this.channels = new CacheManager(async (channelId) => {
            return this.client.channels.fetch(channelId);
        });
        this.users = new CacheManager(async (user_id) => {
            // TODO: If the channel's user cache is empty,
            // and channel.users.fetch(user_id) is called,
            // this function will be triggered to fetch the user detail from the API.
            throw Error(`User ${user_id} not found in this clan ${this.id}!`);
        });
    }
    async loadChannels() {
        if (this._channelsLoaded)
            return;
        if (this._loadingPromise)
            return this._loadingPromise;
        this._loadingPromise = (async () => {
            console.log("---------- call api listChannelDescs");
            const channels = await this.apiClient.listChannelDescs(this.sessionToken, ChannelType.CHANNEL_TYPE_CHANNEL, this.id);
            const validChannels = channels?.channeldesc?.filter((c) => Object.keys(c).length > 0) ??
                [];
            for (const channel of validChannels) {
                const channelObj = new TextChannel({ ...channel, type: channel?.channel_type || channel?.type }, this, this.socketManager, this.messageQueue);
                this.channels.set(channel.channel_id, channelObj);
                this.client.channels.set(channel.channel_id, channelObj);
            }
            this._channelsLoaded = true;
        })();
        return this._loadingPromise;
    }
    async listChannelVoiceUsers(channel_id = "", channel_type = ChannelType.CHANNEL_TYPE_GMEET_VOICE, limit = 500, state, cursor) {
        const clanId = this.id;
        if (limit <= 0 || limit > 500) {
            console.log("0 < limit <= 500");
            throw new Error("0 < limit <= 500");
        }
        return this.apiClient
            .listChannelVoiceUsers(this.sessionToken, clanId, channel_id, channel_type, limit, state, cursor)
            .then((response) => {
            var result = {
                voice_channel_users: [],
            };
            if (response.voice_channel_users == null) {
                return Promise.resolve(result);
            }
            response.voice_channel_users.forEach((gu) => {
                result.voice_channel_users.push({
                    id: gu.id,
                    channel_id: gu.channel_id,
                    user_id: gu.user_id,
                    participant: gu.participant,
                });
            });
            return Promise.resolve(result);
        });
    }
}
//# sourceMappingURL=Clan.js.map