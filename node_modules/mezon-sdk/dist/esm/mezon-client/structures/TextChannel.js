import { convertChanneltypeToChannelMode } from "../../utils/helper";
import { CacheManager } from "../utils/CacheManager";
import { Message } from "./Message";
export class TextChannel {
    id;
    name;
    is_private;
    channel_type;
    category_id;
    category_name;
    parent_id;
    clan;
    messages;
    socketManager;
    messageQueue;
    messageDB;
    constructor(initChannelData, clan, socketManager, messageQueue, messageDB) {
        this.id = initChannelData.channel_id;
        this.name = initChannelData.channel_label;
        this.channel_type = initChannelData?.type;
        this.is_private = !!initChannelData?.channel_private;
        this.category_id = initChannelData?.category_id ?? "";
        this.category_name = initChannelData?.category_name ?? "";
        this.parent_id = initChannelData?.parent_id ?? "";
        this.clan = clan;
        this.messages = new CacheManager(async (message_id) => {
            const messageDb = this.messageDB.getMessageById(message_id, this.id);
            if (!messageDb) {
                throw Error(`Message ${message_id} not found on channel ${this.id}!`);
            }
            const newMessage = new Message(messageDb, this, this.socketManager, this.messageQueue);
            return newMessage;
        }, 200);
        this.socketManager = socketManager;
        this.messageQueue = messageQueue;
        this.messageDB = messageDB;
    }
    async send(content, mentions, attachments, mention_everyone, anonymous_message, topic_id, code) {
        return this.messageQueue.enqueue(async () => {
            const dataSend = {
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: convertChanneltypeToChannelMode(this.channel_type),
                is_public: !this.is_private,
                content,
                mentions,
                attachments,
                anonymous_message,
                mention_everyone,
                code,
                topic_id,
            };
            return await this.socketManager.writeChatMessage(dataSend);
        });
    }
    async sendEphemeral(receiver_id, content, reference_message_id, mentions, attachments, mention_everyone, anonymous_message, topic_id, code) {
        return this.messageQueue.enqueue(async () => {
            let references = [];
            if (reference_message_id) {
                let messageRef = await this.messages.fetch(reference_message_id);
                const user = await this.clan.users.fetch(messageRef.sender_id);
                references = [
                    {
                        message_ref_id: messageRef.id,
                        message_sender_id: messageRef.sender_id,
                        message_sender_username: user.clan_nick || user.display_name || user.username,
                        mesages_sender_avatar: user.clan_avatar || user.avartar,
                        content: JSON.stringify(messageRef.content),
                    },
                ];
            }
            const dataSend = {
                receiver_id,
                clan_id: this.clan.id,
                channel_id: this.id,
                mode: convertChanneltypeToChannelMode(this.channel_type),
                is_public: !this.is_private,
                content,
                mentions,
                attachments,
                references: references ?? [],
                anonymous_message,
                mention_everyone,
                code,
                topic_id,
            };
            return await this.socketManager.writeEphemeralMessage(dataSend);
        });
    }
}
//# sourceMappingURL=TextChannel.js.map