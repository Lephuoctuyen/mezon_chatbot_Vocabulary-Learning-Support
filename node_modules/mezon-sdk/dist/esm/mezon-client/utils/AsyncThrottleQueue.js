const MAX_PER_SECSON = 80;
export class AsyncThrottleQueue {
    maxPerSecond;
    timestamps = [];
    queue = [];
    isRunning = false;
    constructor(maxPerSecond = MAX_PER_SECSON) {
        this.maxPerSecond = maxPerSecond;
        this.start();
    }
    enqueue(task) {
        return new Promise((resolve, reject) => {
            this.queue.push(() => {
                task().then(resolve).catch(reject);
            });
        });
    }
    start() {
        if (this.isRunning)
            return;
        this.isRunning = true;
        const loop = async () => {
            while (true) {
                this.cleanupTimestamps();
                if (this.queue.length > 0 && this.timestamps.length < this.maxPerSecond) {
                    const task = this.queue.shift();
                    if (task) {
                        this.timestamps.push(Date.now());
                        task();
                    }
                }
                await new Promise((r) => setTimeout(r, 10));
            }
        };
        loop();
    }
    cleanupTimestamps() {
        const now = Date.now();
        this.timestamps = this.timestamps.filter(t => now - t < 1000);
    }
}
//# sourceMappingURL=AsyncThrottleQueue.js.map